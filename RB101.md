# RB101 notes
###### Documentation
<https://docs.ruby-lang.org>\
<https://ruby-doc.com>

### Lesson 1 quiz
- note the `def` (in code samples)! This implies return values are important
- need to review return values for various methods, etc
- e.g., what does `[array].each` return?

- need to be careful with loop counters and conditionals
  - *take the time to carefully review edges (start and end)*


### Lesson 2
- call `#methods` on a class or other object to see list of available methods (e.g., `true.methods`)
- remember:  short-circuiting:  `&&` and `||` stop evaluating once a return value can be guaranteed
- example of short-circuiting if `name` is `nil` then code won't evaluate `name.valid?` (a custom method) :
  ```Ruby
  name = find_name

  if name && name.valid?
    puts "great name!"
  else
    puts "either couldn't find name or it's invalid"
  end
  ```
  ---
- Ruby: everything is truthy **except** `false` and `nil`
  - `0` is truthy
  ---
==- local variables initialized within an `if` can be accessed outside of the `if`==
- `if` will return a value (based on what's evaluated)
- can use `[string].inspect` to see printable version of string w/ special characters escaped
- using `each` is considered a *declarative* way to solve problems (e.g., "find largest number in collection")
- using step-by-step (e.g., an iterator) is an *imperative* or *procedural* way to solve problems
- operator precedence <https://ruby-doc.org/core-3.1.2/doc/syntax/precedence_rdoc.html>
  - best to just use `()` to set precedence rather than rely on rules
  - `a = b = c = 3` or `puts a if a == b if a == c`: uses *right*-to-left evaluation
  - note: `{ }` has slightly higher precendence than `do...end`
  - e.g. 
    ```Ruby
    array.map do |num|
      num + 1
    end                         #   => [2, 3, 4]
    ```
    vs
    ```Ruby
    p array.map do |num|
      num + 1                   #  outputs #<Enumerator: [1, 2, 3]:map>
    end                         #  => #<Enumerator: [1, 2, 3]:map>

    # same as
    p array.map                 # outputs <Enumerator: [1, 2, 3]:map>
    ```
    (`do...end` is weaker, `array.map` gets bound to `p` first, then `do...end` block is passed:  `p` prints the Enumerator, but ignores / doesn't evaluate the block)
>
- regex integer number validation: 
  ```Ruby
  def integer?(input)
    /^-?\d+$/.match(input)
  end

  def float?(input)
    /\d/.match(input) && /^-?\d*\.?\d*$/.match(input)  # note \. is an escaped '.' 
  end
  ```
  - `\d` all digits
  - `^` start of the string
  - `+` 'one or more' of preceding matcher
  - `$` end of string
  - `?` 'zero or one'
  - `*` 'zero or more'
  - `.` matches any single character in regex (escaped in example above)
- `CONSTANTS` should be immutable
- Methods:
  - aim for 10 - 15 lines max, otherwise, split them up
  - if you display a value, don't return a meaningful value (i.e., not the intent of the method) i.e.:
    - return value with NO side effects **OR**
    - side effects with NO return value
  - aim for similar levels of abstraction across all methods
  - should focus on 'what' to do rather than 'how'
    - e.g., `iterating_through_cards()` is a 'how', where `deal()`, `hit()`, `stay()` are all 'what' (actions)
- if variables and methods share the same name, then Ruby will access the variable first (unless `()` are used to explicitly call a method)
  ```Ruby
  hello = 'hi'

  def hello
    "Saying hello!"
  end

  puts hello # or puts hello()
  ```






### Debugging

Key steps
1. reproduce the error
2. determine the boundaries of the error
3. trace the code ('trap' the error)
4. understand the problem well
5. implement a fix
6. test the fix



### Rubocop
- `rubocop [filename]`
- `rubocop [filename] --format offenses`

### Pry
- need to `gem install pry`
- add `require "pry"` at top of file
- add `binding.pry` in code
- in Pry:  `Ctrl + D` to continue execution or `exit-program`



### Links
- Ruby Style Guide: <https://rubystyle.guide/>
- asdf (version manager for Ruby, Node.js, etc.) <https://github.com/asdf-vm/asdf>